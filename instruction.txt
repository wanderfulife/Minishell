# Minishell Project

## Objective
Create the parsing part of a simple shell program that mimics basic functionalities of bash.

## Program Name
minishell

## Turn in Files
*.h, *.c

## Crucial Coding Constraints
1. **Function Length and Quantity:**
   - IT IS STRICTLY FORBIDDEN TO WRITE FUNCTIONS OF MORE THAN 25 LINES.
   - ONLY 5 FUNCTIONS PER FILE ARE AUTHORIZED.
   - ONLY AUTHORIZED AND LIBFT FUNCTIONS.
   These rules are of utmost importance and must be followed without exception.

2. **Prohibited Constructs:**
   - FOR LOOPS ARE STRICTLY FORBIDDEN.
   - TERNARY OPERATORS ARE STRICTLY FORBIDDEN.

3. **The project must be written in accordance with the Norm.**
   Ensure your code adheres to the coding standards specified in the Norm.

4. **Global Variables**
   The use of global variables should be limited and justified. Only one global variable is allowed for signal handling.

## Allowed Functions
readline, rl_clear_history, rl_on_new_line, rl_replace_line, rl_redisplay, add_history, printf, malloc, free, write, access, open, read, close, fork, wait, waitpid, wait3, wait4, signal, sigaction, sigemptyset, sigaddset, kill, exit, getcwd, chdir, stat, lstat, fstat, unlink, execve, dup, dup2, pipe, opendir, readdir, closedir, strerror, perror, isatty, ttyname, ttyslot, ioctl, getenv, tcsetattr, tcgetattr, tgetent, tgetflag, tgetnum, tgetstr, tgoto, tputs

## Libft
You will use your own libft library for this project.

## Main Requirements
1. Display a prompt when waiting for a new command.
2. Have a working history.
4. Not interpret unclosed quotes or special characters which are not required by the subject such as \ (backslash) or ; (semicolon).
5. Handle ' (single quote) which should prevent the shell from interpreting the meta-characters in the quoted sequence.
6. Handle " (double quote) which should prevent the shell from interpreting the meta-characters in the quoted sequence except for $ (dollar sign).
7. Implement redirections:
   - < should redirect input.
   - > should redirect output.
   - << should be given a delimiter, then read the input until a line containing the delimiter is seen. However, it doesn't have to update the history!
   - >> should redirect output in append mode.
8. Implement pipes (| character). The output of each command in the pipeline is connected to the input of the next command via a pipe.
9. Handle environment variables ($ followed by a sequence of characters) which should expand to their values.
10. Handle $? which should expand to the exit status of the most recently executed foreground pipeline.



## Error Handling
- Your functions should not quit unexpectedly (segmentation fault, bus error, double free, etc) apart from undefined behaviors.
- All heap allocated memory space must be properly freed when necessary. No leaks will be tolerated.
- If an error occurs, your program must return the appropriate error code.

## Reference Behavior
- For anything not specified, consider bash as a reference.

## Additional Notes
- The readline() function can cause memory leaks. You don't have to fix them. But that doesn't mean your own code can have memory leaks.
- Limit yourself to the subject description. Anything that is not asked is not required.
- If you have any doubt about a requirement, take bash as a reference.
- 

## Remember
- NO FUNCTION SHOULD EXCEED 25 LINES.
- ONLY 5 FUNCTIONS PER FILE ARE ALLOWED.
- FOR LOOPS, SWITCH CASES AND TERNARY OPERATORS ARE PROHIBITED.
- FOLLOW THE VISUAL-PARSING-BREAKDOWN AND GO ONE STEP AT A TIME.
These are strict requirements and core parts of the project constraints.